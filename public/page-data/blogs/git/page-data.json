{"componentChunkName":"component---src-templates-blog-template-js","path":"/blogs/git","result":{"data":{"blog":{"content":"\n# Useful Git Commands\n\n![](https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white) ![](https://img.shields.io/github/followers/EmmanuelPallares.svg?style=social&label=Follow&maxAge=2592000)\n\n\n\n\n## Git\n\n> Git is a distributed version control system, very easy to learn and supper fast!\n\n\n\n### Install Git\n\nThere are a few different ways to install git (from source or for Linux) but the purpose of this page is to focus on git commands, so I am going to assume you are installing git on a Mac.\n\nTo view other ways of installing it visit the [Git official site](http://git-scm.com/book/en/Getting-Started-Installing-Git)\n\nClick [here](http://git-scm.com/download/mac) to download and install Git\n\n\n\n## Setting up git\n\n```sh\n$ git config --global user.name \"User Name\"\n\n$ git config --global user.email \"email\"\n```\n\n## Applying colour to git\n\n\n\n```sh\n$ git config --global color.ui true\n```\n\n#### Initializing a repository in an existing directory\n\n\n\nIf you’re starting to track an existing project in Git, you need to go to the project’s directory and type:\n\n```sh\n$ git init\n```\nThis creates a new subdirectory named .git that contains all of your necessary repository files — a Git repository skeleton. At this point, nothing in your project is tracked yet.\n\nTo start version-controlling existing files you should start by tracking those files and do an initial commit. To accomplish that you should start with a few  `$ git add` that specifies the files you want to track followed by a commit.\n\n```sh\n$ git add <file>\n$ git add README\n$ git commit -m 'Initial project version'\n```\n\n## Checking the status of your files\n\n\n\nThe main tool you use to determine which files are in which state is the `$ git status` command. If you run this command directly after a clone, you should see something like this:\n\n```sh\n$ git status\n# On branch master\nnothing to commit (working directory clean)\n```\n\nIf you add a new file to your project, and the file didn't exist before, when you run a `$ git status` you should see your untracked file like this:\n\n```sh\n$ git status\n# On branch master\n# Untracked files:\n#   (use \"git add <file>...\" to include in what will be committed)\n#\n#   README\nnothing added to commit but untracked files present (use \"git add\" to track)\n```\n\n## Staging files\n\n\n\nAfter initializing a git repository in the chosen directory, all files will now be tracked. Any changes made to any file will be shown after a `$ git status` as changes not staged for commit.\n\nTo stage changes for commit you need to add the file(s) - or in other words, stage file(s).\n\n```sh\n# Adding a file\n$ git add filename\n\n# Adding all files\n$ git add -A\n\n# Adding all files changes in a directory\n$ git add .\n\n# Choosing what changes to add (this will got through all your changes and you can 'Y' or 'N' the changes)\n$ git add -p\n```\n\n## Stashing files\n\n\n\nGit stash is a very useful command, where git will 'hide' the changes on a dirty directory - but no worries you can re-apply them later. The command will save your local changes away and revert the working directory to match the HEAD commit.\n\n```sh\n# Stash local changes\n$ git stash\n\n# Stash local changes with a custom message\n$ git stash save \"this is your custom message\"\n\n# Re-apply the changes you saved in your latest stash\n$ git stash apply\n\n# Re-apply the changes you saved in a given stash number\n$ git stash apply stash@{stash_number}\n\n# Drops any stash by its number\n$ git stash drop stash@{0}\n\n# Apply the stash and then immediately drop it from your stack\n$ git stash pop\n\n# 'Release' a particular stash from your list of stashes\n$ git stash pop stash@{stash_number}\n\n# List all stashes\n$ git stash list\n\n# Show the latest stash changes\n$ git stash show\n\n# See diff details of a given stash number\n$ git diff stash@{0}\n```\n\n## Committing files\n\n\n\nAfter adding/staging a file, the next step is to commit staged file(s)\n\n```sh\n# Commit staged file(s)\n$ git commit -m 'commit message'\n\n# Add file and commit\n$ git commit filename -m 'commit message'\n\n# Add file and commit staged file\n$ git commit -am 'insert commit message'\n\n# Amending a commit\n$ git commit --amend 'new commit message' or no message to maintain previous message\n\n# Squashing commits together\n$ git rebase -i\nThis will give you an interface on your core editor:\n# Commands:\n#  p, pick = use commit\n#  r, reword = use commit, but edit the commit message\n#  e, edit = use commit, but stop for amending\n#  s, squash = use commit, but meld into previous commit\n#  f, fixup = like \"squash\", but discard this commit's log message\n#  x, exec = run command (the rest of the line) using shell\n\n# Squashing commits together using reset --soft\n$ git reset --soft HEAD~number_of_commits\n$ git commit\n** WARNING: this will require force pushing commits, which is OK if this is on a branch before you push to master or create a Pull Request.\n```\n\n## Branching and merging\n\n\n\n```sh\n# Creating a local branch\n$ git checkout -b branchname\n\n# Switching between 2 branches (in fact, this would work on terminal as well to switch between 2 directories - $ cd -)\n$ git checkout -\n\n# Pushing local branch to remote\n$ git push -u origin branchname\n\n# Deleting a local branch - this won't let you delete a branch that hasn't been merged yet\n$ git branch -d branchname\n\n# Deleting a local branch - this WILL delete a branch even if it hasn't been merged yet!\n$ git branch -D branchname\n\n# Remove any remote refs you have locally that have been removed from your remote (you can substitute <origin> to any remote branch)\n$ git remote prune origin\n\n# Viewing all branches, including local and remote branches\n$ git branch -a\n\n# Viewing all branches that have been merged into your current branch, including local and remote\n$ git branch -a --merged\n\n# Viewing all branches that haven't been merged into your current branch, including local and remote\n$ git branch -a --no-merged\n\n# Viewing local branches\n$ git branch\n\n# Viewing remote branches\n$ git branch -r\n\n# Rebase master branch into local branch\n$ git rebase origin/master\n\n# Pushing local branch after rebasing master into local branch\n$ git push origin +branchname\n```\n\n## Fetching and checking out remote branches\n\n\n\n```sh\n# This will fetch all the remote branches for you.\n$ git fetch origin\n\n# With the remote branches in hand, you now need to check out the branch you are interested in, giving you a local working copy:\n$ git checkout -b test origin/test\n\n# Deleting a remote branch\n$ git branch -rd origin/branchname\n$ git push origin --delete branchname  or  $ git push origin:branchname\n```\n\n## Merging branch to trunk/master\n\n\n\n```sh\n# First checkout trunk/master\n$ git checkout trunk/master\n\n# Now merge branch to trunk/master\n$ git merge branchname\n\n# To cancel a merge\n$ git merge --abort\n```\n\n\n\n## Updating a local repository with changes from a Github repository\n\n```sh\n$ git pull origin master\n```\n\n\n\n## Tracking existing branch\n\n```sh\n$ git branch --set-upstream-to=origin/foo foo\n```\n\n\n\n## Resetting\n\n```sh\n# Mixes your head with a give sha\n# This lets you do things like split a commit\n$ git reset --mixed [sha]\n\n# Upstream master\n$ git reset HEAD origin/master -- filename\n\n# The version from the most recent commit\n$ git reset HEAD -- filename\n\n# The version before the most recent commit\n$ git reset HEAD^ -- filename\n\n# Move head to specific commit\n$ git reset --hard sha\n\n# Reset the staging area and the working directory to match the most recent commit. In addition to unstaging changes, the --hard flag tells Git to overwrite all changes in the working directory, too.\n$ git reset --hard\n```\n\n\n## Git remote\n\n```sh\n# Show where 'origin' is pointing to and also tracked branches\n$ git remote show origin\n\n# Show where 'origin' is pointing to\n$ git remote -v\n\n# Change the 'origin' remote's URL\n$ git remote set-url origin https://github.com/user/repo.git\n\n# Add a new 'origin'\n# Usually use to 'rebase' from forks\n$ git remote add [NAME] https://github.com/user/fork-repo.git\n```\n\n\n\n## Git grep\n\n```sh\n# 'Searches' for parts of strings in a directory\n$ git grep 'something'\n\n# 'Searches' for parts of strings in a directory and the -n prints out the line numbers where git has found matches\n$ git grep -n 'something'\n\n# 'Searches' for parts of string in a context (some lines before and some after the grepped term)\n$ git grep -C<number of lines> 'something'\n\n# 'Searches' for parts of string and also shows lines BEFORE the grepped term\n$ git grep -B<number of lines> 'something'\n\n# 'Searches' for parts of string and also shows lines AFTER the grepped term\n$ git grep -A<number of lines> 'something'\n```\n\n\n\n## Git blame\n\n```sh\n# Show alteration history of a file with the name of the author\n$ git blame [filename]\n\n# Show alteration history of a file with the name of the author && SHA\n$ git blame [filename] -l\n```\n\n\n\n## Git log\n\n```sh\n# Show a list of all commits in a repository. This command shows everything about a commit, such as commit ID, author, date and commit message.\n$ git log\n\n# List of commits showing commit messages and changes\n$ git log -p\n\n# List of commits with the particular expression you are looking for\n$ git log -S 'something'\n\n# List of commits by author\n$ git log --author 'Author Name'\n\n# Show a list of commits in a repository in a more summarised way. This shows a shorter version of the commit ID and the commit message.\n$ git log --oneline\n\n# Show a list of commits in a repository since yesterday\n$ git log --since=yesterday\n\n# Shows log by author and searching for specific term inside the commit message\n$ git log --grep \"term\" --author \"name\"\n```\n\n\n\n## Checking what you are committing\n\n```sh\n# See all (non-staged) changes done to a local repo\n$ git diff\n\n# See all (staged) changes done to a local repo\n$ git diff --cached\n\n# Check what the changes between the files you've committed and the live repo\n$ git diff --stat origin/master\n```\n\n\n\n## Useful commands\n\n\n\n```sh\n# Check if a sha is in production\n$ git tag --contains [sha]\n\n# Number of commits by author\n$ git shortlog -s --author 'Author Name'\n\n# List of authors and commits to a repository sorted alphabetically\n$ git shortlog -s -n\n\n# List of commit comments by author\n$ git shortlog -n --author 'Author Name'\n# This also shows the total number of commits by the author\n\n# Number of commits by contributors\n$ git shortlog -s -n\n\n# Undo local changes to a File\n$ git checkout -- filename\n\n# Shows more detailed info about a commit\n$ git cat-file sha -p\n\n# Show number of lines added and removed from a repository by an author since some time in the past.\n$ git log --author=\"Author name\" --pretty=tformat: --numstat --since=month | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }'\n```\n\n","title":"Useful commands Git-Github","id":"Blogs_1"}},"pageContext":{"slug":"git"}},"staticQueryHashes":["4248224382"]}